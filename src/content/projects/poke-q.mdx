---
title: "Poke Queue"
description: "Generacion asincrona de reportes."
date: "2025-10-06"
toc_min_heading_level: 1
toc_max_heading_level: 5
tags:
  [
    "FastApi",
    "Azure",
    "Docker",
    "Python",
    "SQL",
    "Queue",
    "Workers",
    "Terrform",
  ]
---

import Frame from "../../components/Frame.astro";

![Classifier Banner](../../../public/images/poke-q.gif)

<br />
<br />

# Objetivo General

<Frame>
  Es extender y adaptar esta aplicaci√≥n base, a√±adiendo nuevas funcionalidades y
  demostrando tu habilidad para modificar y mejorar un sistema existente que
  debe permanecer desplegado y funcional en Azure.
</Frame>
<br />
<br />

## Contexto Tecnologico

<Frame>

<ol class=' font-mono font-bold'>
  <li >
    -Frontend: Next.js (React)
  </li>
  <li>
  -Backend: API Python con FastAPI desplegada en Azure App Service
  </li>
  <li>
  -Proceso As√≠ncrono: Azure Functions (Python Queue Trigger)
  </li>
  <li>
  -Base de Datos: Azure SQL Database
  </li>
  <li>
  -Almacenamiento: Azure Blob Storage (para los CSV), 
  </li>
  <li>
  -Azure Queue Storage (para mensajes)
  </li>
  <li>
  -API Externa: PokeAPI
  </li>
  <li>
  -Infraestructura como C√≥digo (IaC): Terraform (impl√≠cito por la menci√≥n del
repositorio)
  </li>
</ol>
</Frame>
<br />

# Tarea 1: Implementar Eliminaci√≥n Completa de Reportes

<Frame>

El primer paso para implementar la eliminacion fue crear el correspondiente endpoint:

```jsx
{domain}/api/request/{id} <- METHOD_POST (Para el registro)
```

<br />
Ese endpoint toma el id y hace una busqueda en la base de datos verificando si el
registro existe Si el registro existe entonces ejecuta un metodo que ejecuta un query
donde se elimina el registro, este metodo tambien envia un mensaje al queue DeleteQueue
luego azure worker o azure function llamado serverless-pokeq-dev toma ese mensaje
y procede con la eliminacion del blob file, el cual se hizo mediante el metodo .delete_blob()
que esta incluido en el SDK de Azure.

</Frame>
<br />
<br />

# Tarea 2: Enriquecer Reporte con Detalles del Pok√©mon

<Frame>
Al principio el funcionamiento de la API era el siguiente:
<br/>

Se hacia una peticion `GET` a la API de PokeAPI

```python
https://pokeapi.co/api/v2/type/{type} <- METHOD_GET
```

en donde el parametro `{type}` es el tipo de pokemon del cual nosotros queremos la lista

La consulta a este endpoint nos devuelve la siguiente informacion:

<ol>
  <li>1. **Nombre del pokemon**</li>
  <li>2. **URL del pokemon**</li>
  <li>3. **slot**</li>
</ol>

</Frame>

<Frame>
Para el nuevo funcionamiento:
Se necesitaba extraer datos de la API de Pok√©mon desde dos estructuras diferentes:

1. **Lista b√°sica**: Con nombres y URLs de Pok√©mon

```python
https://pokeapi.co/api/v2/type/{type} <- METHOD_GET
```

<br />
2. **Endpoint detallado**: Con stats y abilities tras hacer peticiones HTTP

```python
https://pokeapi.co/api/v2/pokemon/{id} <- METHOD_GET
```

Inicialmente se cree funciones que manten√≠an la estructura de un diccionario de la forma:

```python
data_dict = {
    "name": "Pokemon",
    "stats": {"hp": 39, "attack": 52, ...},
    "abilities": [{"blaze": "blaze"}, ...]
}
```

Sin embargo para poder dejarlo listo de un dataframe es necesario poder 'Aplanar' esta estructura

</Frame>

<Frame>

## <p class = "text-3xl font-extrabold">Recoleccion de toda la data</p>

<br />
**Proceso**:

- Itera sobre lista de Pok√©mon
- Aplica extracci√≥n individual a cada elemento
- Maneja fallos individuales mediante un Try Catch sin romper el proceso completo

<br />
</Frame>
<Frame>
## <p class = "text-3xl font-extrabold">Aplanamiento de Datos</p>

<br />

**Problema**: DataFrames/CSV no manejan bien estructuras anidadas
Para Stats: Sacar todo de la caja
Los stats estaban guardados en una "caja" llamada "stats". La soluci√≥n fue romper esa caja y poner cada stat directamente como una columna separada en la tabla.
Es como si tuvieras una carpeta llamada "Calificaciones" con hojas sueltas adentro. En lugar de tener la carpeta, sacas cada hoja y las pones directamente sobre el escritorio, cada una con su propio lugar.

- Stats: `stats.hp` ‚Üí `hp` (columna directa)

```python
# Antes
pokemon_data['stats'] = {"hp": 39, "attack": 52, "defense": 43}

# Despu√©s - Se promocionan al nivel principal
for stat_item in pokemon_data['stats']:
    stat_name = stat_item['stat']['name']    # 'hp'
    base_stat = stat_item['base_stat']       # 39
    flat_data[stat_name] = base_stat         # flat_data['hp'] = 39
```

Para Abilities: Expandir horizontalmente
Las abilities eran una lista de elementos complejos (cada ability ten√≠a nombre, si era oculta, y un n√∫mero de slot). No pod√≠as poner una lista en una celda de Excel.
La soluci√≥n fue crear m√∫ltiples columnas para cada ability: una columna para el nombre de la primera ability, otra para si es oculta, otra para su slot. Luego lo mismo para la segunda ability, y as√≠ sucesivamente.

- Abilities: Array complejo ‚Üí m√∫ltiples columnas (`ability_1_name`, `ability_1_is_hidden`, etc.)

```python
# Antes
"abilities": [
    {"name": "blaze", "is_hidden": false, "slot": 1},
    {"name": "solar-power", "is_hidden": true, "slot": 3}
]

# Despu√©s - Una columna por cada atributo de cada ability
abilities = extract_abilities(pokemon_data['abilities'])
for i, ability in enumerate(abilities, 1):
    flat_data[f'ability_{i}_name'] = ability['name']        # ability_1_name: blaze
    flat_data[f'ability_{i}_is_hidden'] = ability['is_hidden']  # ability_1_is_hidden: false
```

</Frame>

<Frame>

## <p class = "text-3xl font-extrabold">Manejo de Abilities Variables</p>

**Problema**: Pok√©mon tienen diferente n√∫mero de habilidades

**Soluci√≥n**:

```python
# Columnas din√°micas por habilidad
ability_1_name,
ability_2_name
# + columnas resumen
all_abilities: "blaze, solar-power"
total_abilities: 2
```

</Frame>
<Frame>
## <p class = "text-3xl font-extrabold">Organizaci√≥n de Columnas</p>

Se estableci√≥ un orden l√≥gico:

1. **Identificaci√≥n**: name, url
2. **Stats de combate**: hp, attack, defense, etc.
3. **Resumen de abilities**: total_abilities, all_abilities
4. **Detalles de abilities**: ability_1_name, ability_2_name, etc.

name -> url -> hp -> attack -> defense -> special-attack -> special-defense -> speed -> total_abilities -> all_abilities -> ability_1_name -> ability_2_name -> ability_3_name -> etc

</Frame>
<Frame>

## <p class = "text-3xl font-extrabold">DataFrame</p>

El DataFrame nos permite organizar los datos de una manera tabular, lo que nos beneficia porque queremos exportar un CSV

Con los datos previamente aplanados y las columnas tambien ordenadas solo ulilizamos la libreria Pandas creamos el dataframe y poblarlo a partir de nuestra lista.

</Frame>
<Frame>

## <p class = "text-3xl font-extrabold">Exportaci√≥n</p>

Para la exportacion se utilizo el metodo previamente creado y solo fue cuestion de pasarle el nuevo blob_file

</Frame>
<Frame>

## <p class = "text-3xl font-extrabold">Manejo de Errores</p>

- Peticiones HTTP con try-catch
- Contin√∫a procesando aunque falte un Pok√©mon
- Mensajes informativos de progreso

</Frame>
<br />

# Tarea 3: Reportes con Muestreo Aleatorio

Permite al usuario especificar un n√∫mero m√°ximo de registros aleatorios a incluir
en el reporte.

<Frame>
  ## <p class="text-3xl font-extrabold">Frontend</p>
  <br />
  Utilizando la libreria radix-ui se utilizo el componente ```label-input```
  para obtener el tama√±o del sample desde el lado del clientes
</Frame>

<Frame>
## <p class = "text-3xl font-extrabold">Backend</p>

<br />
Se modifico el endpoint ```http://{domain}/api/requests/{type}/{sample_size}``` para
obtener mediante un path variable el numero de registros requeridos por el usuario
Se modifico el modelo en pydantic de manera que este tuviera un nuevo campo llamado
`sample_size` que es un numero entero mayor o igual a cero (0) Se hizo la modificacion
correspondiente en la base de datos y tambien en el procedimiento almacenado para
seguir utilizando esa misma funcionalidad solamente con peque√±os ajustes

</Frame>

<Frame>
## <p class = "text-3xl font-extrabold">Worker - Azure Function</p>

<br />
Mediante la funcion ```get_request(id)``` obtenemos un json con los datos de la solicitud,
incluyendo el sample size, aprovechamos esto para para validar si el tama√±o deseado
de la muestra es menor a numero de registros que contiene el tipo de pokemon requerido
por el usuario, si llega a ser menor entonces utilizamos la funcion 'Recortamos'
el arreglo con la lista de pokemones antes de que se agreguen todos los detalles
que utilizaremos en el dataframe de la siguiente manera: ```python sample_pokemon_list
= pokemon_list[:random.randint(1, list_len)] ``` si la muestra requerida por el usuario
llega a ser mayor que la lista obtenia desde la API de Pokemon entonces devolveremos
todos los pokemones del mismo tipo que esten disponibles en la API

</Frame>

<Frame>
## <p class = "text-3xl font-extrabold">Resultado final en el CSV</p>

```python
name,url,hp,attack,defense,special-attack,special-defense,speed,total_abilities,all_abilities,ability_1_name,ability_2_name,ability_3_name
charmander,https://pokeapi.co/api/v2/pokemon/4/,39,52,43,60,50,65,2,"blaze, solar-power",blaze,solar-power,
charmeleon,https://pokeapi.co/api/v2/pokemon/5/,58,64,58,80,65,80,2,"blaze, solar-power",blaze,solar-power,
charizard,https://pokeapi.co/api/v2/pokemon/6/,78,84,78,109,85,100,2,"blaze, solar-power",blaze,solar-power,
```

</Frame>

<Frame>
# üîó Enlaces importantes:

<br />
<ol >
  <li class='text-white font-mono font-bold hover:text-green-500 transition-colors'>
    {" "}
    [üîó Portal UI - Desplegado](https://ui-pokeq-dev.azurewebsites.net/)
  </li>
  <li class='text-white font-mono font-bold hover:text-green-500 transition-colors'>
    {" "}
    [üîó API - Desplegado](https://api-pokeq-dev.azurewebsites.net/)
  </li>
  <li class='text-white font-mono font-bold hover:text-green-500 transition-colors'>
    {" "}
    [üîó Repositorio en GitHub de la API](https://github.com/ricjpg/pokeq.api)
  </li>
  <li class='text-white font-mono font-bold hover:text-green-500 transition-colors'>
    {" "}
    [üîó Repositorio en GitHub de la UI](https://github.com/ricjpg/pokeq.ui)
  </li>
  <li class='text-white font-mono font-bold hover:text-green-500 transition-colors'>
    {" "}
    [üîó Repositorio en GitHub del Azure Function](https://github.com/ricjpg/pokeq.funct)
  </li>
  <li class='text-white font-mono font-bold hover:text-green-500 transition-colors'>
    {" "}
    [üîó Repositorio en GitHub de la Base de datos](https://github.com/ricjpg/pokeq.sql)
  </li>
  <li class='text-white font-mono font-bold hover:text-green-500 transition-colors'>
    {" "}
    [üîó Repositorio en GitHub de la Arquitectura](https://github.com/ricjpg/pokeq.tf)
  </li>
  <li class='text-white font-mono font-bold hover:text-green-500 transition-colors'>
    {" "}
    [üîó Demostracion de Funcionalidades Principales](https://youtu.be/Mc8Sg_zIL_s)
  </li>
</ol>
</Frame>
```
````
